---
title: "Eindopdracht"
author: "Mohammed Al Hor"
date: "2022-12-24"
output:
  word_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown
```{r}
#libs
library(dplyr)
library(readr)
library(ggplot2)
library(gridExtra)
library(lmtest)
library(moments)
library(tseries)
library(stringr)
library(forecast)
library(car)
```

## Deelvraag 1,2 
Deze zeer relevante dataset bevat de dagelijkse personeelsverliezen aan Russische kant van de oorlog in Ukraine. In dit rapport gaan we kijken naar EDA (Exploratory Data Analysis) doen en daarna een stukje forecasting proberen te doen op deze data. Verschillende visualisaties en modellen zullen aan bod komen. Deze modellen gaan we met elkaar vergelijken om uiteindelijk het beste model uit te kiezen en deze te gebruiken om voorspellingen te doen.
Inladen van de data:
```{r}
setwd("~/Data-Science-Business-Analytics/Data")
russia_losses_personnel <- read_csv("russia_losses_personnel.csv")
```


Onderstaand figuur geeft ons een eerste blik op de data. Omdat we het hier hebben over cummulatieve personeelsverlizen zien we uitereaard een stijgende lijn in dit aantal. 
```{r}
plot1 <- ggplot(russia_losses_personnel, aes(x=date, y=personnel)) +geom_line() + labs(title = "Cummulatieve dagelijkse personeelsverliezen")
plot1
```


De eerste verschillen (first differences) worden berekend, zodat we deze kunnen visualizeren.
```{r}
russia_losses_personnel <- russia_losses_personnel %>% mutate(diff = personnel - lag(personnel))
```

Cummulatieve en dagelijkse/incrementel personeelsverliezen onder elkaar.
```{r}
require(gridExtra)
plot2 <- ggplot(russia_losses_personnel, aes(x=date, y=diff)) +geom_point() + geom_smooth() + labs(title = "Incrementele dagelijkse personeelsverliezen")
grid.arrange(plot1, plot2, ncol=1)
```
We observeren een aanzienlijke variantie wat betreft personeelsverliezen in de eerste dagen van de oorlog. Een verklaring voor deze variantie is het feit dat er in de eerste dagen de personeelsverliezen niet dagelijks werden geupdated. We zien voor sommige dagen nul personeelsverliezen die in de opvolgende dagen worden overgecompenseerd. 

Laten we de dataset opdelen in een training en test set.
```{r}
estimation_sample <- russia_losses_personnel %>% filter(date <= '2022-10-03')
test_sample <- russia_losses_personnel %>% filter(date > '2022-10-03')
```


We berekenen de (partitiele) autocorrelaties voor de cummulatieve personeelsverliezen(niveau):
```{r}
max_lag <- 15
acf_pacf <- tibble(lag = 1:max_lag,
                   acf = acf(estimation_sample$personnel, max_lag)$acf[2:(max_lag + 1)],
                   pacf = pacf(estimation_sample$personnel, max_lag)$acf)
```
De ACF of autocorrelatie functie in bovenstaand figuur geeft de correlatie weer over de tijd tussen de verschillende momenten. We observeren dat de eerste 15 momenten significant en afnemend zijn. Dit wekt de suggestie dat er een lange termijn trend in de data zit en deze dus niet stationair is. We zouden nog een ADF (Augmented Dickey Fuller) test kunnen doen om dit te bevestigen.
```{r}
adf.test(estimation_sample$personnel)
```
Hoge p-waarde maakt het dat we de null hypothese niet kunnen verwerpen (cummulatieve personeelsverliezen zijn dus niet stationair).


## Deelvraag 3
We gaan verder met de verschillen. Omdat het aantal personeelsverliezen cummulatief is en een trend vertoont (zie ACF) gaan we een methode toepassen die 'detrending' of 'first differencing' wordt genoemd. Deze hebben we in vorige vraag al berekend.


## Deelvraag 4
Laten we nu gaan kijken naar de (partitiele) autocorrelaties voor incrementele/dagelijkse personeelsverliezen.

```{r}
estimation_sample$diff[is.na(estimation_sample$diff)] <- 2800 
acf_pacf <- tibble(lag = 1:max_lag,
                   acf = acf(estimation_sample$diff, max_lag)$acf[2:(max_lag + 1)],
                   pacf = pacf(estimation_sample$diff, max_lag)$acf)
```
De ACF toont dat de 1ste, 2de, 3de, 5de en 6de momenten significant zijn. De partitiele ACF toont dat de 1ste, 2de, 3de, 5de en 6de momenten significant zijn. Deze informatie kunnen we gebruiken bij het modelleren van deze data.


## Deelvraag 5
Voordat we met het leuke werk gaan beginnen moeten we we eerst een check doen of onze data stationair is. Dit houdt in dat de mean en de variantie constant moeten zijn en er geen seizoenseffecten in mogen zitten. Hiervoor gebruiken we de ADF, ofwel Augmented Dickey Fueller test.

```{r}
adf.test(estimation_sample$diff)
```

P-waarde is kleiner dan 0.05, we kunnen de null hypothese verwerpen en aannemen dat de data stationair is.


Omdat er geen 'cut off' point zit in beide grafieken kunnen we geen definitieve keuze maken tussen een AR of MA model. Ons eerste model wordt dus een ARMA model. De parameters voor dit model gaan we schatten door middel van het 'forecast' package. De 'auto.arima' functie in dit package geeft het beste model terug op basis van AIC. Het beste model (laagste AIC) is een ARIMA(3,0,3) model. De parameters worden weergegeven in de onderstaande output:

```{r}
stepwise_fit_1 <- auto.arima(estimation_sample$diff, stationary = TRUE)
summary(stepwise_fit_1)
arma_1 <- arima(estimation_sample$diff, c(3,0,3))
cf <- coef(arma_1) # coefficienten ophalen
```
## Deelvraag 6
In dit onderdeel gaan we een 'deep-dive' doen op dit model, eerst kijken we naar de residuals ten op zichte van de werkelijke waardes en zetten we deze in een grafiek.

```{r}
actuals_predict <- tibble(
  actual = estimation_sample$diff[1:nrow(estimation_sample)],
  fitted = fitted.values(arma_1),
  residual = residuals(arma_1)
) %>%
  mutate(n = 1:n())
```

```{r}
ggplot(actuals_predict, aes(x = n)) +
  geom_line(aes(y = actual), color = "red") +
  geom_line(aes(y = fitted), color = "green") +
  geom_line(aes(y = residual), color = "blue") + labs(title = "Actual vs. Fitted values") 
?geom_line()
```
Bovenstaand figuur geeft in het rood de werkelijke waardes terug, in het groen de geschatte en in het blauw de residuen.

Laten we hierop wat diagnostische testen doen. We beginnen met de Ljung Box test om te checken voor residual autocorrelatie. De null hypothese van is dat de data onafhankelijk zijn verdeeld. 
```{r}
lb_test_result <- Box.test(actuals_predict$residual, lag = 1, type = c("Ljung-Box"),) # fit
lb_test_result
?Box.test
```
Met een p-waarde van 0.4652 kunnen we de null-hypothese niet verwerpen. De residuen zijn onafhankelijk verdeeld en dit is wat we willen hebben voor een correct model.

We kunnen aan de hand van wat getallen en grafieken een kijkje nemen naar de normaliteit van de residuen.

```{r}
ggplot(actuals_predict) +
  geom_histogram(aes(x = residual), bins = 12)
```

In dit histogram zien we wat uitschieters in de residuen, maar de verdeling ziet er er redelijk normaal uit.

Summary statistics:

```{r}
summary(actuals_predict$residual)
```

Standaard deviatie:

```{r}
sd(actuals_predict$residual)
```
we zien een standaard deviatie van ongeveer 218.
Skewness:

```{r}
skewness(actuals_predict$residual)
```
We zien een positieve skewness van 2.14, dit is hoog (skewness > 1). De uitschieters in bovenstaande histogram zijn hier waarschijnlijk de oorzaak van.


## Deelvraag 7
In dit onderdeel gaan we twee alternatieve modellen bekijken. Allereerst beschouwen we een ARIMA model op cummulatieve personeelsverliezen. Wederom wordt de 'auto.arima' functie gebruikt om het optimale model te bepalen. Let op: cummulatieve personeelsverliezen zijn niet stationair, dit hebben we hiervoor getoetst. Om deze reden wordt dit als argument meegegeven. In de onderstaande output staan de parameters die horen bij dit model:
```{r}
stepwise_fit_2 <- auto.arima(estimation_sample$personnel, stationary = FALSE)
summary(stepwise_fit_2)
arma_2 <- arima(estimation_sample$personnel, c(2,2,4))
cf <- coef(arma_2) # coefficienten ophalen
```
Het beste model dat wordt teruggegeven door de 'auto.arima' functie is een ARIMA(2,2,4). Er is dus twee keer differencing toegepast. De AIC van dit model is iets lager dan het vorige model. Hieronder worden de residuen in een tabel gezet en geplot in een figuur.

```{r}
actuals_predict_2 <- tibble(
  actual = estimation_sample$personnel[1:nrow(estimation_sample)],
  fitted = fitted.values(arma_2),
  residual = residuals(arma_2)
) %>%
  mutate(n = 1:n())
```

```{r}
ggplot(actuals_predict_2, aes(x = n)) +
  geom_line(aes(y = actual), color = "red") +
  geom_line(aes(y = fitted), color = "green") +
  geom_line(aes(y = residual), color = "blue")
```
Bovenstaand figuur geeft in het rood de werkelijke waardes terug, in het groen de geschatte en in het blauw de residuen. Wederom zorgt de variantie aan het begin voor hogere residuen.

Laten we ook een simpel autoregressief model beschouwen met 1 lag. In de onderstaande output staan de parameters die horen bij dit model:
```{r}
ar_1 <- arima(estimation_sample$personnel, c(1,0,0))
summary(ar_1)
```
Hieronder worden de residuen in een tabel gezet en geplot in een figuur.
```{r}
actuals_predict_3 <- tibble(
  actual = estimation_sample$personnel[1:nrow(estimation_sample)],
  fitted = fitted.values(ar_1),
  residual = residuals(ar_1)
) %>%
  mutate(n = 1:n())
```

```{r}
ggplot(actuals_predict_3, aes(x = n)) +
  geom_line(aes(y = actual), color = "red") +
  geom_line(aes(y = fitted), color = "green") +
  geom_line(aes(y = residual), color = "blue")
```
Laten we de AIC bekijken van de verschillende modellen. Het AR(1) model heeft een AIC van 3265, het ARIMA(2,2,4) model een AIC van 3032 en het eerste ARMA(3,0,3) model heeft een AIC van 3029. Dit zit redelijk dicht bij elkaar, maar het ARMA(3,0,3) model heeft de laagste AIC. We kiezen dus voor nu voor het ARMA(3,0,3) model. Verder zien we voor de overige modellen dat de geschatte waardes allemaal heel dicht liggen bij de werkelijke waardes. Hoewel deze modellen op de huidige data goede voorspellingen kunnen doen, zou dit ook een geval van 'overfitting' kunnen zijn.



## Deelvraag 8
Hieronder de voorspellingen van de voorgaande modellen op de testdata.

ARIMA(3,0,3):

```{r}
arima_forecast_1 <- forecast::Arima(y = test_sample$diff, order = c(3, 0, 3))
summary(arima_forecast_1)
fitted(arima_forecast_1)
```

```{r}
actuals_forecast_1 <- tibble(
  actual = test_sample$diff[1:nrow(test_sample)],
  fitted = fitted.values(arima_forecast_1),
  residual = residuals(arima_forecast_1)
) %>%
  mutate(n = 1:n())
```

```{r}
ggplot(actuals_forecast_1, aes(x = n)) +
  geom_line(aes(y = actual), color = "red") +
  geom_line(aes(y = fitted), color = "green") +
  geom_line(aes(y = residual), color = "blue")
```

ARIMA(2,2,4):

```{r}
arima_forecast_2 <- forecast::Arima(y = test_sample$personnel, order = c(2, 2, 4))
summary(arima_forecast_2)
fitted(arima_forecast_2)
```

```{r}
actuals_forecast_2 <- tibble(
  actual = test_sample$personnel[1:nrow(test_sample)],
  fitted = fitted.values(arima_forecast_2),
  residual = residuals(arima_forecast_2)
) %>%
  mutate(n = 1:n())
```

```{r}
ggplot(actuals_forecast_2, aes(x = n)) +
  geom_line(aes(y = actual), color = "red") +
  geom_line(aes(y = fitted), color = "green") +
  geom_line(aes(y = residual), color = "blue")
```


AR(1):

```{r}
arima_forecast_3 <- forecast::Arima(y = test_sample$personnel, order = c(1, 0, 0), method = 'ML')
summary(arima_forecast_3)
fitted(arima_forecast_3)
```

```{r}
actuals_forecast_3 <- tibble(
  actual = test_sample$personnel[1:nrow(test_sample)],
  fitted = fitted.values(arima_forecast_3),
  residual = residuals(arima_forecast_3)
) %>%
  mutate(n = 1:n())
```

```{r}
ggplot(actuals_forecast_3, aes(x = n)) +
  geom_line(aes(y = actual), color = "red") +
  geom_line(aes(y = fitted), color = "green") +
  geom_line(aes(y = residual), color = "blue")
```

Het ARIMA(2,2,4) en het ARIMA(3,0,3) model hebben de laagste AIC, respectievelijk 955 en 977. Om een keuze te maken tussen deze twee modellen gaan we de residuen bekijken. We voeren een ADF toets uit om te controleren of deze stationair zijn.

```{r}
residuals(arima_forecast_1)
```
Voor het ARIMA(3,0,3) model krijgen we een p-waarde die groter is dan 0.05. We kunnen de null hypothese niet verwerpen en de residuen zijn dus niet stationair

```{r}
adf.test(residuals(arima_forecast_2))
```
Het ARIMA(2,2,4) model op cummulatieve personeelsverliezen heeft een p-waarde kleiner dan 0.05. Deze data is dus wel stationair en is ons voorkeursmodel. 

## Deelvraag 9
```{r}
arima_forecast_final <- forecast::Arima(y = russia_losses_personnel$diff, order = c(3, 0, 3))
summary(arima_forecast_final)
fitted(arima_forecast_final)
```

```{r}
upper <- fitted(arima_forecast_final) + 1.96*sqrt(arima_forecast_final$sigma2)
lower <- fitted(arima_forecast_final) - 1.96*sqrt(arima_forecast_final$sigma2)
plot(russia_losses_personnel$diff, type="n", ylim=range(lower,upper))
polygon(c(time(russia_losses_personnel$date),rev(time(russia_losses_personnel$date))), c(upper,rev(lower)), col=rgb(0,0,0.6,0.2), border=FALSE)
lines(russia_losses_personnel$diff)
lines(fitted(arima_forecast_final),col='red')
out <- (russia_losses_personnel$diff < lower | russia_losses_personnel$diff > upper)
points(time(russia_losses_personnel$diff)[out], russia_losses_personnel$diff[out], pch=19)
```
In bovenstaande figuur zijn de voorspellingen in het rood, de werkelijke waardes in het zwart en de betrouwbaarheidsintervallen geplot. In de grafiek zien in het begin van de oorlog veel variantie in de personeelsverliezen. Dit maakt het voor het model lastig om voorpellingen te doen en dat zien we terug in de grafiek.




```{r}
arima_forecast_final_1 <- forecast::Arima(y = russia_losses_personnel$personnel, order = c(2, 2, 4))
summary(arima_forecast_final_1)
fitted(arima_forecast_final_1)
```

```{r}
# russia_losses_personnel$personnel[is.na(russia_losses_personnel$personnel)] <- 0 
upper <- log(fitted(arima_forecast_final_1) + 1.96*sqrt(arima_forecast_final_1$sigma2))
lower <- log(fitted(arima_forecast_final_1) - 1.96*sqrt(arima_forecast_final_1$sigma2))
plot(russia_losses_personnel$personnel, type="n", ylim=range(lower,upper))
polygon(c(time(russia_losses_personnel$date),rev(time(russia_losses_personnel$date))), c(upper,rev(lower)), col=rgb(0,0,0.6,0.2), border=FALSE)
lines(log(russia_losses_personnel$personnel))
lines(log(fitted(arima_forecast_final_1)),col='red')
out <- (log(russia_losses_personnel$personnel) < lower | log(russia_losses_personnel$personnel) > upper)
points(time(russia_losses_personnel$personnel)[out], russia_losses_personnel$personnel[out], pch=19)
```



